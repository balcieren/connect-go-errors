# connect-go-errors

[![Test](https://github.com/balcieren/connect-go-errors/actions/workflows/test.yml/badge.svg)](https://github.com/balcieren/connect-go-errors/actions/workflows/test.yml)
[![Lint](https://github.com/balcieren/connect-go-errors/actions/workflows/lint.yml/badge.svg)](https://github.com/balcieren/connect-go-errors/actions/workflows/lint.yml)
[![Go Reference](https://pkg.go.dev/badge/github.com/balcieren/connect-go-errors.svg)](https://pkg.go.dev/github.com/balcieren/connect-go-errors)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

A **proto-first**, type-safe error handling package for [Connect RPC](https://connectrpc.com) services. Define errors once in `.proto` files, auto-generate Go code, and use them everywhere with full IDE support.

## Why connect-go-errors?

```protobuf
// Define once in proto
option (connectgoerrors.v1.connect_error) = {
  code: "ERROR_USER_NOT_FOUND"
  message: "User '{{id}}' not found"
  connect_code: "not_found"
};
```

```go
// Use everywhere in Go
return nil, cerr.New(userv1.ErrUserNotFound, cerr.M{"id": req.Id})
// â†’ "User '123' not found" with full type safety
```

**No magic strings. No copy-paste errors. Full IDE autocomplete.**

## Features

| Feature                 | Description                                             |
| ----------------------- | ------------------------------------------------------- |
| ðŸ”§ **Proto-first**      | Define errors in `.proto` files alongside your services |
| âš¡ **Code Generation**  | `protoc-gen-connect-errors` generates typed constants   |
| ðŸ“ **Named Templates**  | `{{placeholder}}` syntax for dynamic messages           |
| ðŸŽ¯ **Type-safe**        | Every error code is a typed constant with IDE support   |
| ðŸ”„ **Retryable Errors** | Built-in support for marking errors as retryable        |
| ðŸª **Interceptor**      | Server-side hook for logging, metrics, and tracing      |
| âœ… **errors.Is/As**     | Standard Go error matching support                      |

## Quick Start

### Installation

```bash
go get github.com/balcieren/connect-go-errors
go install github.com/balcieren/connect-go-errors/cmd/protoc-gen-connect-errors@latest
```

---

## Proto-Based Error Definition (Recommended)

The recommended approach is to define errors directly in your `.proto` files. This keeps error definitions co-located with your service definitions and enables code generation.

### Project Structure

```text
your-project/
â”œâ”€â”€ buf.yaml                 # Buf module configuration
â”œâ”€â”€ buf.gen.yaml             # Code generation configuration
â”œâ”€â”€ proto/
â”‚   â””â”€â”€ user/
â”‚       â””â”€â”€ v1/
â”‚           â””â”€â”€ service.proto
â””â”€â”€ gen/
    â””â”€â”€ go/
        â””â”€â”€ user/
            â””â”€â”€ v1/
                â”œâ”€â”€ service.pb.go
                â”œâ”€â”€ service_connect.go
                â””â”€â”€ service_connect_errors.go  â† Generated by this plugin
```

### Step 1: Configure buf.yaml

```yaml
# buf.yaml
version: v2
modules:
  - path: proto
deps:
  # Add the connect-go-errors proto extension
  - buf.build/balcieren/connect-go-errors
  # Required for google.protobuf.MethodOptions
  - buf.build/protocolbuffers/wellknowntypes
```

```bash
buf dep update
```

### Step 2: Configure buf.gen.yaml

```yaml
# buf.gen.yaml
version: v2

managed:
  enabled: true
  override:
    - file_option: go_package_prefix
      value: github.com/yourorg/yourapp/gen/go

plugins:
  # Standard protobuf Go generation
  - local: protoc-gen-go
    out: gen/go
    opt: paths=source_relative

  # Connect RPC client/server generation
  - local: protoc-gen-connect-go
    out: gen/go
    opt: paths=source_relative

  # â­ Error constants and registry generation
  - local: protoc-gen-connect-errors
    out: gen/go
    opt: paths=source_relative
```

> **Note:** Make sure `protoc-gen-connect-errors` is installed:
>
> ```bash
> go install github.com/balcieren/connect-go-errors/cmd/protoc-gen-connect-errors@latest
> ```

### Step 3: Define Errors on RPC Methods

```protobuf
syntax = "proto3";
package user.v1;

import "connectgoerrors/v1/error.proto";

service UserService {
  rpc GetUser(GetUserRequest) returns (User) {
    option (connectgoerrors.v1.connect_error) = {
      code: "ERROR_USER_NOT_FOUND"
      message: "User '{{id}}' not found"
      connect_code: "not_found"
      retryable: false
    };
    option (connectgoerrors.v1.connect_error) = {
      code: "ERROR_INVALID_USER_ID"
      message: "Invalid user ID format: '{{id}}'"
      connect_code: "invalid_argument"
      retryable: false
    };
  };

  rpc DeleteUser(DeleteUserRequest) returns (Empty) {
    option (connectgoerrors.v1.connect_error) = {
      code: "ERROR_USER_NOT_FOUND"
      message: "User '{{id}}' not found"
      connect_code: "not_found"
      retryable: false
    };
    option (connectgoerrors.v1.connect_error) = {
      code: "ERROR_DELETE_FORBIDDEN"
      message: "Cannot delete user: {{reason}}"
      connect_code: "permission_denied"
      retryable: false
    };
  };
}
```

### Step 4: Generate Code

```bash
buf generate
```

The plugin generates a `*_connect_errors.go` file with error sentinels and auto-registration:

```go
// Code generated by protoc-gen-connect-errors. DO NOT EDIT.
package userv1

import (
    "connectrpc.com/connect"
    cerr "github.com/balcieren/connect-go-errors"
)

// Error sentinel variables for use with errors.Is and cerr.New.
var (
    ErrUserNotFound    = cerr.NewCodedError("ERROR_USER_NOT_FOUND")
    ErrInvalidUserId   = cerr.NewCodedError("ERROR_INVALID_USER_ID")
    ErrDeleteForbidden = cerr.NewCodedError("ERROR_DELETE_FORBIDDEN")
)

func init() {
    cerr.RegisterAll([]cerr.Error{
        {
            Code:        "ERROR_USER_NOT_FOUND",
            MessageTpl:  "User '{{id}}' not found",
            ConnectCode: connect.CodeNotFound,
            Retryable:   false,
        },
        // ... other errors auto-registered
    })
}
```

> **Note:** Duplicate error codes across methods are automatically deduplicated.

### Step 5: Use in Your Handlers

```go
package main

import (
    cerr "github.com/balcieren/connect-go-errors"
    userv1 "github.com/yourorg/yourapp/gen/go/user/v1"
)

func (s *UserServer) GetUser(ctx context.Context, req *connect.Request[userv1.GetUserRequest]) (*connect.Response[userv1.User], error) {
    user, err := s.db.FindUser(ctx, req.Msg.Id)
    if err != nil {
        // Type-safe, auto-registered with correct message template
        return nil, cerr.New(userv1.ErrUserNotFound, cerr.M{"id": req.Msg.Id})
    }
    return connect.NewResponse(user), nil
}
```

---

## Manual Usage (Without Proto Generation)

If you prefer not to use proto-based definitions, you can use the built-in error codes or register custom ones:

### Using Built-in Codes

```go
import cerr "github.com/balcieren/connect-go-errors"

func GetUser(ctx context.Context, id string) (*User, error) {
    if id == "" {
        return nil, cerr.New(cerr.ErrInvalidArgument, cerr.M{
            "reason": "id is required",
        })
    }

    user, err := repo.GetByID(ctx, id)
    if err != nil {
        return nil, cerr.Wrap(cerr.ErrNotFound, err, cerr.M{"id": id})
    }

    return user, nil
}
```

### Registering Custom Errors

```go
func init() {
    cerr.Register(cerr.Error{
        Code:        "ERROR_EMAIL_EXISTS",
        MessageTpl:  "Email '{{email}}' is already registered",
        ConnectCode: connect.CodeAlreadyExists,
        Retryable:   false,
    })
}

// Usage
return nil, cerr.New("ERROR_EMAIL_EXISTS", cerr.M{"email": email})
```

---

## API Reference

### Error Creation Functions

| Function                          | Description                                   |
| --------------------------------- | --------------------------------------------- |
| `New(code, data)`                 | Create error from registry with template data |
| `NewWithMessage(code, msg, data)` | Override default template message             |
| `Newf(code, format, args...)`     | fmt.Sprintf-style formatting                  |
| `Wrap(code, err, data)`           | Wrap underlying error with context            |
| `FromCode(code, msg)`             | Create directly from connect.Code             |

```go
// New - uses registered template
cerr.New(cerr.ErrNotFound, cerr.M{"id": "123"})

// NewWithMessage - custom template
cerr.NewWithMessage(cerr.ErrNotFound, "User '{{id}}' deleted", cerr.M{"id": "123"})

// Newf - printf-style
cerr.Newf(cerr.ErrNotFound, "User %q not found", userID)

// Wrap - preserve original error
cerr.Wrap(cerr.ErrInternal, err, cerr.M{})

// FromCode - bypass registry
cerr.FromCode(connect.CodeInternal, "unexpected error")
```

### Error Inspection

```go
// Extract domain error from *connect.Error
if def, ok := cerr.FromError(connectErr); ok {
    log.Printf("code: %s, retryable: %t", def.Code, def.Retryable)
}

// Get just the error code
if code, ok := cerr.ErrorCode(connectErr); ok {
    log.Printf("error code: %s", code)
}

// Check if retryable
if cerr.IsRetryable(code) {
    // implement retry logic
}
```

### Error Matching (errors.Is / errors.As)

```go
// Define sentinel errors
var ErrNotFound = cerr.NewCodedError(cerr.ErrNotFound)
var ErrInternal = cerr.NewCodedError(cerr.ErrInternal)

// Match by error code
connectErr := cerr.New(cerr.ErrNotFound, cerr.M{"id": "123"})
errors.Is(connectErr.Unwrap(), ErrNotFound)  // true
errors.Is(connectErr.Unwrap(), ErrInternal)  // false

// Extract CodedError
var coded *cerr.CodedError
if errors.As(connectErr.Unwrap(), &coded) {
    fmt.Println(coded.ErrorCode()) // "ERROR_NOT_FOUND"
}
```

### Server-Side Interceptor

// Customizing Header Keys (Optional)
func init() {
cerr.SetHeaderKeys("x-custom-error-code", "x-custom-retryable")
}

// Interceptor for logging, metrics, or adding details
func NewAuthInterceptor() connect.UnaryInterceptorFunc {
return func(next connect.UnaryFunc) connect.UnaryFunc {
return func(ctx context.Context, req connect.AnyRequest) (connect.AnyResponse, error) {
// Example: Check for authentication
// if !isAuthenticated(ctx) {
// return nil, cerr.New(cerr.ErrUnauthenticated, nil)
// }
return next(ctx, req)
}
}
}

Use `ErrorInterceptor` for centralized error logging, metrics, or tracing:

```go
interceptor := cerr.ErrorInterceptor(func(ctx context.Context, err *connect.Error, def cerr.Error) {
    slog.ErrorContext(ctx, "rpc error",
        "code", def.Code,
        "connect_code", def.ConnectCode,
        "retryable", def.Retryable,
    )
    metrics.IncrCounter("rpc.error", "code", def.Code)
})

mux.Handle(userv1connect.NewUserServiceHandler(svc,
    connect.WithInterceptors(interceptor),
))
```

### Template Functions

```go
// Extract placeholder names
fields := cerr.TemplateFields("User '{{id}}' in {{org}}")
// â†’ ["id", "org"]

// Validate data against template
err := cerr.ValidateTemplate("User '{{id}}'", cerr.M{})
// â†’ error: missing fields: id

// Format template manually
msg := cerr.FormatTemplate("User '{{id}}'", cerr.M{"id": "123"})
// â†’ "User '123'"
```

---

## Built-in Error Codes

These codes are pre-registered and ready to use:

| Constant                | Code                        | Connect Code             | Retryable |
| ----------------------- | --------------------------- | ------------------------ | --------- |
| `ErrNotFound`           | `ERROR_NOT_FOUND`           | `CodeNotFound`           | No        |
| `ErrInvalidArgument`    | `ERROR_INVALID_ARGUMENT`    | `CodeInvalidArgument`    | No        |
| `ErrAlreadyExists`      | `ERROR_ALREADY_EXISTS`      | `CodeAlreadyExists`      | No        |
| `ErrPermissionDenied`   | `ERROR_PERMISSION_DENIED`   | `CodePermissionDenied`   | No        |
| `ErrUnauthenticated`    | `ERROR_UNAUTHENTICATED`     | `CodeUnauthenticated`    | No        |
| `ErrInternal`           | `ERROR_INTERNAL`            | `CodeInternal`           | No        |
| `ErrUnavailable`        | `ERROR_UNAVAILABLE`         | `CodeUnavailable`        | Yes       |
| `ErrDeadlineExceeded`   | `ERROR_DEADLINE_EXCEEDED`   | `CodeDeadlineExceeded`   | Yes       |
| `ErrResourceExhausted`  | `ERROR_RESOURCE_EXHAUSTED`  | `CodeResourceExhausted`  | Yes       |
| `ErrFailedPrecondition` | `ERROR_FAILED_PRECONDITION` | `CodeFailedPrecondition` | No        |
| `ErrAborted`            | `ERROR_ABORTED`             | `CodeAborted`            | Yes       |
| `ErrUnimplemented`      | `ERROR_UNIMPLEMENTED`       | `CodeUnimplemented`      | No        |
| `ErrCanceled`           | `ERROR_CANCELED`            | `CodeCanceled`           | No        |
| `ErrDataLoss`           | `ERROR_DATA_LOSS`           | `CodeDataLoss`           | No        |

---

## Error Metadata

Every error includes HTTP/gRPC metadata headers:

| Header         | Description                 | Example           |
| -------------- | --------------------------- | ----------------- |
| `x-error-code` | Domain error code           | `ERROR_NOT_FOUND` |
| `x-retryable`  | Whether client should retry | `true` / `false`  |

---

## Contributing

See [CONTRIBUTING.md](docs/CONTRIBUTING.md) for guidelines.

## License

[MIT](LICENSE)
