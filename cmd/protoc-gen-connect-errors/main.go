// protoc-gen-connect-errors is a protoc plugin that generates type-safe
// error constants and registry initialization code from proto error definitions.
//
// Usage:
//
//	protoc --connect-errors_out=. --connect-errors_opt=paths=source_relative proto/*.proto
package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/encoding/protowire"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

const version = "0.1.3"

func main() {
	showVersion := flag.Bool("version", false, "print version")
	flag.Parse()

	if *showVersion {
		fmt.Fprintf(os.Stderr, "protoc-gen-connect-errors %s\n", version)
		os.Exit(0)
	}

	opts := protogen.Options{
		ParamFunc: func(name, value string) error {
			switch name {
			case "paths":
				// handled by protogen internally
			default:
				return fmt.Errorf("unknown parameter %q", name)
			}
			return nil
		},
	}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

type errorDef struct {
	Code        string
	Message     string
	ConnectCode string
	Retryable   bool
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	var errors []errorDef

	for _, svc := range file.Services {
		for _, method := range svc.Methods {
			opts := method.Desc.Options()
			if opts == nil {
				continue
			}

			// Look for connect_error extensions (field number 50001)
			raw := opts.(*descriptorpb.MethodOptions)
			if raw == nil {
				continue
			}

			// Parse extensions from unknown fields
			b, err := proto.Marshal(raw)
			if err != nil {
				continue
			}

			// Walk the wire-format bytes looking for field 50001 (connect_error extension)
			defs := parseConnectErrors(b)
			errors = append(errors, defs...)
		}
	}

	if len(errors) == 0 {
		return
	}

	// Deduplicate errors by code (same error may appear on multiple methods)
	seen := make(map[string]bool, len(errors))
	unique := make([]errorDef, 0, len(errors))
	for _, e := range errors {
		if !seen[e.Code] {
			seen[e.Code] = true
			unique = append(unique, e)
		}
	}
	errors = unique

	filename := file.GeneratedFilenamePrefix + "_connect_errors.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-connect-errors. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"connectrpc.com/connect"`)
	g.P()
	g.P(`	cerr "github.com/balcieren/connect-go-errors"`)
	g.P(")")
	g.P()

	// Generate error sentinel variables
	g.P("// Error sentinel variables for use with errors.Is and cerr.New.")
	g.P("var (")
	for _, e := range errors {
		varName := "Err" + errorCodeToConstant(e.Code)
		g.P(fmt.Sprintf("\t%s = cerr.NewCodedError(%q)", varName, e.Code))
	}
	g.P(")")
	g.P()

	// Generate init function
	g.P("func init() {")
	g.P("\tcerr.RegisterAll([]cerr.Error{")
	for _, e := range errors {
		g.P("\t\t{")
		g.P(fmt.Sprintf("\t\t\tCode:        %q,", e.Code))
		g.P(fmt.Sprintf("\t\t\tMessageTpl:  %q,", e.Message))
		g.P(fmt.Sprintf("\t\t\tConnectCode: %s,", mapConnectCode(e.ConnectCode)))
		g.P(fmt.Sprintf("\t\t\tRetryable:   %t,", e.Retryable))
		g.P("\t\t},")
	}
	g.P("\t})")
	g.P("}")
}

// parseConnectErrors extracts ErrorDef messages from wire-format MethodOptions
// by looking for field number 50001 (the connect_error extension).
func parseConnectErrors(b []byte) []errorDef {
	var defs []errorDef
	for len(b) > 0 {
		num, wtype, n := protowire.ConsumeTag(b)
		if n < 0 {
			break
		}
		b = b[n:]

		switch wtype {
		case protowire.VarintType:
			_, n = protowire.ConsumeVarint(b)
		case protowire.Fixed32Type:
			_, n = protowire.ConsumeFixed32(b)
		case protowire.Fixed64Type:
			_, n = protowire.ConsumeFixed64(b)
		case protowire.BytesType:
			v, vn := protowire.ConsumeBytes(b)
			n = vn
			if num == 50001 && n > 0 {
				if def, ok := parseErrorDef(v); ok {
					defs = append(defs, def)
				}
			}
		case protowire.StartGroupType:
			_, n = protowire.ConsumeGroup(num, b)
		default:
			return defs
		}

		if n < 0 {
			break
		}
		b = b[n:]
	}
	return defs
}

// parseErrorDef parses a single ErrorDef message from wire-format bytes.
// ErrorDef fields: code(1), message(2), connect_code(3), retryable(4).
func parseErrorDef(b []byte) (errorDef, bool) {
	var def errorDef
	var found bool
	for len(b) > 0 {
		num, wtype, n := protowire.ConsumeTag(b)
		if n < 0 {
			break
		}
		b = b[n:]

		switch wtype {
		case protowire.VarintType:
			v, vn := protowire.ConsumeVarint(b)
			n = vn
			if num == 4 {
				def.Retryable = v != 0
				found = true
			}
		case protowire.BytesType:
			v, vn := protowire.ConsumeBytes(b)
			n = vn
			switch num {
			case 1:
				def.Code = string(v)
				found = true
			case 2:
				def.Message = string(v)
				found = true
			case 3:
				def.ConnectCode = string(v)
				found = true
			}
		default:
			// Skip unknown wire types
			switch wtype {
			case protowire.Fixed32Type:
				_, n = protowire.ConsumeFixed32(b)
			case protowire.Fixed64Type:
				_, n = protowire.ConsumeFixed64(b)
			case protowire.StartGroupType:
				_, n = protowire.ConsumeGroup(num, b)
			default:
				return def, false
			}
		}

		if n < 0 {
			break
		}
		b = b[n:]
	}
	return def, found
}

func errorCodeToConstant(code string) string {
	name := strings.TrimPrefix(code, "ERROR_")
	parts := strings.Split(name, "_")
	var result string
	for _, p := range parts {
		if len(p) > 0 {
			result += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}
	return result
}

func mapConnectCode(code string) string {
	m := map[string]string{
		"canceled":            "connect.CodeCanceled",
		"unknown":             "connect.CodeUnknown",
		"invalid_argument":    "connect.CodeInvalidArgument",
		"deadline_exceeded":   "connect.CodeDeadlineExceeded",
		"not_found":           "connect.CodeNotFound",
		"already_exists":      "connect.CodeAlreadyExists",
		"permission_denied":   "connect.CodePermissionDenied",
		"resource_exhausted":  "connect.CodeResourceExhausted",
		"failed_precondition": "connect.CodeFailedPrecondition",
		"aborted":             "connect.CodeAborted",
		"out_of_range":        "connect.CodeOutOfRange",
		"unimplemented":       "connect.CodeUnimplemented",
		"internal":            "connect.CodeInternal",
		"unavailable":         "connect.CodeUnavailable",
		"data_loss":           "connect.CodeDataLoss",
		"unauthenticated":     "connect.CodeUnauthenticated",
	}
	if v, ok := m[code]; ok {
		return v
	}
	return "connect.CodeInternal"
}
