// protoc-gen-connect-errors is a protoc plugin that generates type-safe
// error constants and registry initialization code from proto error definitions.
//
// Usage:
//
//	protoc --connect-errors_out=. --connect-errors_opt=paths=source_relative proto/*.proto
package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/encoding/protowire"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

var version = "0.2.0"

func main() {
	showVersion := flag.Bool("version", false, "print version")
	flag.Parse()

	if *showVersion {
		fmt.Fprintf(os.Stderr, "protoc-gen-connect-errors %s\n", version)
		os.Exit(0)
	}

	opts := protogen.Options{
		ParamFunc: func(name, value string) error {
			switch name {
			case "paths":
				// handled by protogen internally
			default:
				return fmt.Errorf("unknown parameter %q", name)
			}
			return nil
		},
	}

	opts.Run(func(gen *protogen.Plugin) error {
		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}
			generateFile(gen, f)
		}
		return nil
	})
}

type errorDef struct {
	Code        string
	Message     string
	ConnectCode string
	Retryable   bool
}

func generateFile(gen *protogen.Plugin, file *protogen.File) {
	var errors []errorDef

	// Parse file-level error definitions (field number 50002)
	fileOpts := file.Desc.Options()
	if fileOpts != nil {
		raw := fileOpts.(*descriptorpb.FileOptions)
		if raw != nil {
			if b, err := proto.Marshal(raw); err == nil {
				defs := parseExtensionErrors(b, 50002)
				errors = append(errors, defs...)
			}
		}
	}

	// Parse method-level error definitions (field number 50001)
	for _, svc := range file.Services {
		for _, method := range svc.Methods {
			opts := method.Desc.Options()
			if opts == nil {
				continue
			}

			raw := opts.(*descriptorpb.MethodOptions)
			if raw == nil {
				continue
			}

			b, err := proto.Marshal(raw)
			if err != nil {
				continue
			}

			defs := parseExtensionErrors(b, 50001)
			errors = append(errors, defs...)
		}
	}

	if len(errors) == 0 {
		return
	}

	// Deduplicate errors by code (same error may appear on multiple methods)
	seen := make(map[string]bool, len(errors))
	unique := make([]errorDef, 0, len(errors))
	for _, e := range errors {
		if !seen[e.Code] {
			seen[e.Code] = true
			unique = append(unique, e)
		}
	}
	errors = unique

	filename := file.GeneratedFilenamePrefix + "_connect_errors.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	g.P("// Code generated by protoc-gen-connect-errors. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`	"errors"`)
	g.P()
	g.P(`	"connectrpc.com/connect"`)
	g.P()
	g.P(`	cerr "github.com/balcieren/connect-go-errors"`)
	g.P(")")
	g.P()

	// Generate error code constants (type-safe)
	g.P("// Error code constants for use with cerr.New, cerr.Wrap, etc.")
	g.P("const (")
	for _, e := range errors {
		varName := "Err" + errorCodeToConstant(e.Code)
		g.P(fmt.Sprintf("\t%s cerr.ErrorCode = %q", varName, e.Code))
	}
	g.P(")")
	g.P()

	// Generate error sentinel variables for errors.Is/As support
	g.P("// Error sentinel variables for use with errors.Is.")
	g.P("var (")
	for _, e := range errors {
		varName := "Err" + errorCodeToConstant(e.Code) + "Sentinel"
		constName := "Err" + errorCodeToConstant(e.Code)
		g.P(fmt.Sprintf("\t%s = cerr.NewCodedError(%s)", varName, constName))
	}
	g.P(")")
	g.P()

	// Generate init function
	g.P("func init() {")
	g.P("\tcerr.RegisterAll([]cerr.Error{")
	for _, e := range errors {
		constName := "Err" + errorCodeToConstant(e.Code)
		g.P("\t\t{")
		g.P(fmt.Sprintf("\t\t\tCode:        string(%s),", constName))
		g.P(fmt.Sprintf("\t\t\tMessageTpl:  %q,", e.Message))
		g.P(fmt.Sprintf("\t\t\tConnectCode: %s,", mapConnectCode(e.ConnectCode)))
		g.P(fmt.Sprintf("\t\t\tRetryable:   %t,", e.Retryable))
		g.P("\t\t},")
	}
	g.P("\t})")
	g.P("}")
	g.P()

	// Generate typed constructor functions with struct parameters
	g.P("// Typed constructor functions for compile-time safe error creation.")
	g.P("// Parameters are derived from {{placeholder}} fields in message templates.")
	for _, e := range errors {
		constName := "Err" + errorCodeToConstant(e.Code)
		baseName := errorCodeToConstant(e.Code)
		funcName := "New" + baseName
		fields := extractTemplateFields(e.Message)

		if len(fields) == 0 {
			// No placeholders → no-arg constructor
			g.P(fmt.Sprintf("// %s creates a *connect.Error for %s.", funcName, e.Code))
			g.P(fmt.Sprintf("func %s() *connect.Error {", funcName))
			g.P(fmt.Sprintf("\treturn cerr.New(%s, nil)", constName))
			g.P("}")
		} else {
			// Generate params struct
			structName := baseName + "Params"
			g.P(fmt.Sprintf("// %s holds the template fields for %s.", structName, e.Code))
			g.P(fmt.Sprintf("type %s struct {", structName))
			for _, f := range fields {
				g.P(fmt.Sprintf("\t%s string", fieldToExportedName(f)))
			}
			g.P("}")
			g.P()

			// Generate constructor
			g.P(fmt.Sprintf("// %s creates a *connect.Error for %s.", funcName, e.Code))
			g.P(fmt.Sprintf("func %s(p %s) *connect.Error {", funcName, structName))

			// Build cerr.M{} from struct fields
			var mapEntries []string
			for _, f := range fields {
				mapEntries = append(mapEntries, fmt.Sprintf("%q: p.%s", f, fieldToExportedName(f)))
			}
			g.P(fmt.Sprintf("\treturn cerr.New(%s, cerr.M{%s})", constName, strings.Join(mapEntries, ", ")))
			g.P("}")
		}
		g.P()
	}

	// Generate client-side IsXxx error matchers
	g.P("// Client-side error matchers for checking errors returned by Connect RPC calls.")
	for _, e := range errors {
		baseName := errorCodeToConstant(e.Code)
		constName := "Err" + baseName
		funcName := "Is" + baseName
		g.P(fmt.Sprintf("// %s reports whether err is a %s error.", funcName, e.Code))
		g.P(fmt.Sprintf("func %s(err error) bool {", funcName))
		g.P("\tvar connectErr *connect.Error")
		g.P("\tif !errors.As(err, &connectErr) {")
		g.P("\t\treturn false")
		g.P("\t}")
		g.P("\tcode, ok := cerr.ExtractErrorCode(connectErr)")
		g.P(fmt.Sprintf("\treturn ok && code == string(%s)", constName))
		g.P("}")
		g.P()
	}
}

// parseExtensionErrors extracts ErrorDef messages from wire-format options
// by looking for the specified field number.
func parseExtensionErrors(b []byte, fieldNum protowire.Number) []errorDef {
	var defs []errorDef
	for len(b) > 0 {
		num, wtype, n := protowire.ConsumeTag(b)
		if n < 0 {
			break
		}
		b = b[n:]

		switch wtype {
		case protowire.VarintType:
			_, n = protowire.ConsumeVarint(b)
		case protowire.Fixed32Type:
			_, n = protowire.ConsumeFixed32(b)
		case protowire.Fixed64Type:
			_, n = protowire.ConsumeFixed64(b)
		case protowire.BytesType:
			v, vn := protowire.ConsumeBytes(b)
			n = vn
			if num == fieldNum && n > 0 {
				if def, ok := parseErrorDef(v); ok {
					defs = append(defs, def)
				}
			}
		case protowire.StartGroupType:
			_, n = protowire.ConsumeGroup(num, b)
		default:
			return defs
		}

		if n < 0 {
			break
		}
		b = b[n:]
	}
	return defs
}

// parseErrorDef parses a single ErrorDef message from wire-format bytes.
// ErrorDef fields: code(1), message(2), connect_code(3), retryable(4).
func parseErrorDef(b []byte) (errorDef, bool) {
	var def errorDef
	var found bool
	for len(b) > 0 {
		num, wtype, n := protowire.ConsumeTag(b)
		if n < 0 {
			break
		}
		b = b[n:]

		switch wtype {
		case protowire.VarintType:
			v, vn := protowire.ConsumeVarint(b)
			n = vn
			if num == 4 {
				def.Retryable = v != 0
				found = true
			}
		case protowire.BytesType:
			v, vn := protowire.ConsumeBytes(b)
			n = vn
			switch num {
			case 1:
				def.Code = string(v)
				found = true
			case 2:
				def.Message = string(v)
				found = true
			case 3:
				def.ConnectCode = string(v)
				found = true
			}
		default:
			// Skip unknown wire types
			switch wtype {
			case protowire.Fixed32Type:
				_, n = protowire.ConsumeFixed32(b)
			case protowire.Fixed64Type:
				_, n = protowire.ConsumeFixed64(b)
			case protowire.StartGroupType:
				_, n = protowire.ConsumeGroup(num, b)
			default:
				return def, false
			}
		}

		if n < 0 {
			break
		}
		b = b[n:]
	}
	return def, found
}

func errorCodeToConstant(code string) string {
	name := strings.TrimPrefix(code, "ERROR_")
	parts := strings.Split(name, "_")
	var result string
	for _, p := range parts {
		if len(p) > 0 {
			result += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
		}
	}
	return result
}

// extractTemplateFields parses {{placeholder}} names from a message template.
// Returns unique fields in order of first appearance.
func extractTemplateFields(message string) []string {
	var fields []string
	seen := make(map[string]bool)
	i := 0
	for i < len(message) {
		start := strings.Index(message[i:], "{{")
		if start == -1 {
			break
		}
		start += i
		end := strings.Index(message[start:], "}}")
		if end == -1 {
			break
		}
		end += start
		field := message[start+2 : end]
		if field != "" && !seen[field] {
			seen[field] = true
			fields = append(fields, field)
		}
		i = end + 2
	}
	return fields
}

// fieldToExportedName converts a snake_case template field to a PascalCase Go exported name.
// e.g. "product_id" → "ProductId", "email" → "Email"
func fieldToExportedName(field string) string {
	parts := strings.Split(field, "_")
	var result string
	for _, p := range parts {
		if len(p) == 0 {
			continue
		}
		result += strings.ToUpper(p[:1]) + strings.ToLower(p[1:])
	}
	return result
}

func mapConnectCode(code string) string {
	m := map[string]string{
		"canceled":            "connect.CodeCanceled",
		"unknown":             "connect.CodeUnknown",
		"invalid_argument":    "connect.CodeInvalidArgument",
		"deadline_exceeded":   "connect.CodeDeadlineExceeded",
		"not_found":           "connect.CodeNotFound",
		"already_exists":      "connect.CodeAlreadyExists",
		"permission_denied":   "connect.CodePermissionDenied",
		"resource_exhausted":  "connect.CodeResourceExhausted",
		"failed_precondition": "connect.CodeFailedPrecondition",
		"aborted":             "connect.CodeAborted",
		"out_of_range":        "connect.CodeOutOfRange",
		"unimplemented":       "connect.CodeUnimplemented",
		"internal":            "connect.CodeInternal",
		"unavailable":         "connect.CodeUnavailable",
		"data_loss":           "connect.CodeDataLoss",
		"unauthenticated":     "connect.CodeUnauthenticated",
	}
	if v, ok := m[code]; ok {
		return v
	}
	return "connect.CodeInternal"
}
