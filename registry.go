package connectgoerrors

import (
	"fmt"
	"sort"
	"sync"
	"sync/atomic"

	"connectrpc.com/connect"
)

// Error code constants for common RPC error scenarios.
// These are auto-generated by protoc-gen-connect-errors or defined manually.
const (
	// ErrNotFound indicates the requested resource was not found.
	ErrNotFound = "ERROR_NOT_FOUND"

	// ErrInvalidArgument indicates a client-supplied argument was invalid.
	ErrInvalidArgument = "ERROR_INVALID_ARGUMENT"

	// ErrAlreadyExists indicates an attempt to create a resource that already exists.
	ErrAlreadyExists = "ERROR_ALREADY_EXISTS"

	// ErrPermissionDenied indicates the caller lacks permission for the operation.
	ErrPermissionDenied = "ERROR_PERMISSION_DENIED"

	// ErrUnauthenticated indicates the request lacks valid authentication credentials.
	ErrUnauthenticated = "ERROR_UNAUTHENTICATED"

	// ErrInternal indicates an unexpected internal server error.
	ErrInternal = "ERROR_INTERNAL"

	// ErrUnavailable indicates the service is currently unavailable.
	ErrUnavailable = "ERROR_UNAVAILABLE"

	// ErrDeadlineExceeded indicates the operation timed out.
	ErrDeadlineExceeded = "ERROR_DEADLINE_EXCEEDED"

	// ErrResourceExhausted indicates some resource has been exhausted (e.g. rate limit).
	ErrResourceExhausted = "ERROR_RESOURCE_EXHAUSTED"

	// ErrFailedPrecondition indicates the operation was rejected because
	// the system is not in a state required for execution.
	ErrFailedPrecondition = "ERROR_FAILED_PRECONDITION"

	// ErrAborted indicates the operation was aborted (e.g. concurrency conflict).
	ErrAborted = "ERROR_ABORTED"

	// ErrUnimplemented indicates the operation is not implemented or supported.
	ErrUnimplemented = "ERROR_UNIMPLEMENTED"

	// ErrCanceled indicates the operation was canceled by the caller.
	ErrCanceled = "ERROR_CANCELED"

	// ErrDataLoss indicates unrecoverable data loss or corruption.
	ErrDataLoss = "ERROR_DATA_LOSS"
)

// Error represents a Connect RPC error definition with template support.
// It maps a semantic error code to a Connect status code and message template.
type Error struct {
	// Code is the unique error identifier (e.g. "ERROR_NOT_FOUND").
	Code string

	// MessageTpl is a message template with {{placeholder}} syntax.
	MessageTpl string

	// ConnectCode is the Connect RPC status code for this error.
	ConnectCode connect.Code

	// Retryable indicates whether the client should retry the request.
	Retryable bool
}

// writeMu protects Registry writes. Reads are lock-free via atomic.Value.
var writeMu sync.Mutex

// registryVal stores an immutable map[string]Error snapshot.
// Reads are lock-free (atomic load). Writes copy-on-write under writeMu.
var registryVal atomic.Value

// defaultErrors is the default error definitions. This is used to initialize registryVal.
// After init, use Lookup/Register/RegisterAll to interact with the registry.
var defaultErrors = map[string]Error{
	ErrNotFound: {
		Code:        ErrNotFound,
		MessageTpl:  "Resource '{{id}}' not found",
		ConnectCode: connect.CodeNotFound,
		Retryable:   false,
	},
	ErrInvalidArgument: {
		Code:        ErrInvalidArgument,
		MessageTpl:  "Invalid argument: {{reason}}",
		ConnectCode: connect.CodeInvalidArgument,
		Retryable:   false,
	},
	ErrAlreadyExists: {
		Code:        ErrAlreadyExists,
		MessageTpl:  "Resource '{{id}}' already exists",
		ConnectCode: connect.CodeAlreadyExists,
		Retryable:   false,
	},
	ErrPermissionDenied: {
		Code:        ErrPermissionDenied,
		MessageTpl:  "Permission denied: {{reason}}",
		ConnectCode: connect.CodePermissionDenied,
		Retryable:   false,
	},
	ErrUnauthenticated: {
		Code:        ErrUnauthenticated,
		MessageTpl:  "Authentication required",
		ConnectCode: connect.CodeUnauthenticated,
		Retryable:   false,
	},
	ErrInternal: {
		Code:        ErrInternal,
		MessageTpl:  "Internal server error",
		ConnectCode: connect.CodeInternal,
		Retryable:   false,
	},
	ErrUnavailable: {
		Code:        ErrUnavailable,
		MessageTpl:  "Service temporarily unavailable",
		ConnectCode: connect.CodeUnavailable,
		Retryable:   true,
	},
	ErrDeadlineExceeded: {
		Code:        ErrDeadlineExceeded,
		MessageTpl:  "Request timed out",
		ConnectCode: connect.CodeDeadlineExceeded,
		Retryable:   true,
	},
	ErrResourceExhausted: {
		Code:        ErrResourceExhausted,
		MessageTpl:  "Resource exhausted: {{reason}}",
		ConnectCode: connect.CodeResourceExhausted,
		Retryable:   true,
	},
	ErrFailedPrecondition: {
		Code:        ErrFailedPrecondition,
		MessageTpl:  "Failed precondition: {{reason}}",
		ConnectCode: connect.CodeFailedPrecondition,
		Retryable:   false,
	},
	ErrAborted: {
		Code:        ErrAborted,
		MessageTpl:  "Operation aborted: {{reason}}",
		ConnectCode: connect.CodeAborted,
		Retryable:   true,
	},
	ErrUnimplemented: {
		Code:        ErrUnimplemented,
		MessageTpl:  "Operation not implemented",
		ConnectCode: connect.CodeUnimplemented,
		Retryable:   false,
	},
	ErrCanceled: {
		Code:        ErrCanceled,
		MessageTpl:  "Operation canceled",
		ConnectCode: connect.CodeCanceled,
		Retryable:   false,
	},
	ErrDataLoss: {
		Code:        ErrDataLoss,
		MessageTpl:  "Unrecoverable data loss",
		ConnectCode: connect.CodeDataLoss,
		Retryable:   false,
	},
}

// Register adds or updates an error definition in the global Registry.
// It is safe for concurrent use. Uses copy-on-write for lock-free reads.
//
// Example:
//
//	connectgoerrors.Register(connectgoerrors.Error{
//	    Code:        "ERROR_CUSTOM",
//	    MessageTpl:  "Custom error: {{detail}}",
//	    ConnectCode: connect.CodeInternal,
//	    Retryable:   false,
//	})
func Register(err Error) {
	writeMu.Lock()
	defer writeMu.Unlock()
	current := loadRegistry()
	updated := make(map[string]Error, len(current)+1)
	for k, v := range current {
		updated[k] = v
	}
	updated[err.Code] = err
	registryVal.Store(updated)
}

// RegisterAll adds multiple error definitions to the global Registry.
// It is safe for concurrent use. Uses copy-on-write for lock-free reads.
func RegisterAll(errs []Error) {
	writeMu.Lock()
	defer writeMu.Unlock()
	current := loadRegistry()
	updated := make(map[string]Error, len(current)+len(errs))
	for k, v := range current {
		updated[k] = v
	}
	for _, err := range errs {
		updated[err.Code] = err
	}
	registryVal.Store(updated)
}

// Lookup retrieves an error definition from the Registry by its code.
// Lock-free: uses atomic load, no mutex overhead.
//
// Example:
//
//	e, ok := connectgoerrors.Lookup(connectgoerrors.NotFound)
func Lookup(code string) (Error, bool) {
	m := loadRegistry()
	e, ok := m[code]
	return e, ok
}

// MustLookup retrieves an error definition by code and panics if not found.
// Use this only during initialization or in tests.
func MustLookup(code string) Error {
	e, ok := Lookup(code)
	if !ok {
		panic(fmt.Sprintf("connectgoerrors: unknown error code %q", code))
	}
	return e
}

// Codes returns all registered error codes in sorted order.
// Useful for debugging, documentation, or building admin UIs.
func Codes() []string {
	m := loadRegistry()
	codes := make([]string, 0, len(m))
	for k := range m {
		codes = append(codes, k)
	}
	sort.Strings(codes)
	return codes
}

// loadRegistry returns the current immutable registry snapshot.
func loadRegistry() map[string]Error {
	v := registryVal.Load()
	if v == nil {
		return nil
	}
	return v.(map[string]Error)
}

func init() {
	registryVal.Store(defaultErrors)
}
