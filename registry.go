package connectgoerrors

import (
	"fmt"
	"sort"
	"sync"
	"sync/atomic"

	"connectrpc.com/connect"
)

// Error code constants for common RPC error scenarios.
// These are auto-generated by protoc-gen-connect-errors or defined manually.
const (
	// NotFound indicates the requested resource was not found.
	NotFound = "ERROR_NOT_FOUND"

	// InvalidArgument indicates a client-supplied argument was invalid.
	InvalidArgument = "ERROR_INVALID_ARGUMENT"

	// AlreadyExists indicates an attempt to create a resource that already exists.
	AlreadyExists = "ERROR_ALREADY_EXISTS"

	// PermissionDenied indicates the caller lacks permission for the operation.
	PermissionDenied = "ERROR_PERMISSION_DENIED"

	// Unauthenticated indicates the request lacks valid authentication credentials.
	Unauthenticated = "ERROR_UNAUTHENTICATED"

	// Internal indicates an unexpected internal server error.
	Internal = "ERROR_INTERNAL"

	// Unavailable indicates the service is currently unavailable.
	Unavailable = "ERROR_UNAVAILABLE"

	// DeadlineExceeded indicates the operation timed out.
	DeadlineExceeded = "ERROR_DEADLINE_EXCEEDED"

	// ResourceExhausted indicates some resource has been exhausted (e.g. rate limit).
	ResourceExhausted = "ERROR_RESOURCE_EXHAUSTED"

	// FailedPrecondition indicates the operation was rejected because
	// the system is not in a state required for execution.
	FailedPrecondition = "ERROR_FAILED_PRECONDITION"

	// Aborted indicates the operation was aborted (e.g. concurrency conflict).
	Aborted = "ERROR_ABORTED"

	// Unimplemented indicates the operation is not implemented or supported.
	Unimplemented = "ERROR_UNIMPLEMENTED"

	// Canceled indicates the operation was canceled by the caller.
	Canceled = "ERROR_CANCELED"

	// DataLoss indicates unrecoverable data loss or corruption.
	DataLoss = "ERROR_DATA_LOSS"
)

// Error represents a Connect RPC error definition with template support.
// It maps a semantic error code to a Connect status code and message template.
type Error struct {
	// Code is the unique error identifier (e.g. "ERROR_NOT_FOUND").
	Code string

	// MessageTpl is a message template with {{placeholder}} syntax.
	MessageTpl string

	// ConnectCode is the Connect RPC status code for this error.
	ConnectCode connect.Code

	// Retryable indicates whether the client should retry the request.
	Retryable bool
}

// writeMu protects Registry writes. Reads are lock-free via atomic.Value.
var writeMu sync.Mutex

// registryVal stores an immutable map[string]Error snapshot.
// Reads are lock-free (atomic load). Writes copy-on-write under writeMu.
var registryVal atomic.Value

// defaultErrors is the default error definitions. This is used to initialize registryVal.
// After init, use Lookup/Register/RegisterAll to interact with the registry.
var defaultErrors = map[string]Error{
	NotFound: {
		Code:        NotFound,
		MessageTpl:  "Resource '{{id}}' not found",
		ConnectCode: connect.CodeNotFound,
		Retryable:   false,
	},
	InvalidArgument: {
		Code:        InvalidArgument,
		MessageTpl:  "Invalid argument: {{reason}}",
		ConnectCode: connect.CodeInvalidArgument,
		Retryable:   false,
	},
	AlreadyExists: {
		Code:        AlreadyExists,
		MessageTpl:  "Resource '{{id}}' already exists",
		ConnectCode: connect.CodeAlreadyExists,
		Retryable:   false,
	},
	PermissionDenied: {
		Code:        PermissionDenied,
		MessageTpl:  "Permission denied: {{reason}}",
		ConnectCode: connect.CodePermissionDenied,
		Retryable:   false,
	},
	Unauthenticated: {
		Code:        Unauthenticated,
		MessageTpl:  "Authentication required",
		ConnectCode: connect.CodeUnauthenticated,
		Retryable:   false,
	},
	Internal: {
		Code:        Internal,
		MessageTpl:  "Internal server error",
		ConnectCode: connect.CodeInternal,
		Retryable:   false,
	},
	Unavailable: {
		Code:        Unavailable,
		MessageTpl:  "Service temporarily unavailable",
		ConnectCode: connect.CodeUnavailable,
		Retryable:   true,
	},
	DeadlineExceeded: {
		Code:        DeadlineExceeded,
		MessageTpl:  "Request timed out",
		ConnectCode: connect.CodeDeadlineExceeded,
		Retryable:   true,
	},
	ResourceExhausted: {
		Code:        ResourceExhausted,
		MessageTpl:  "Resource exhausted: {{reason}}",
		ConnectCode: connect.CodeResourceExhausted,
		Retryable:   true,
	},
	FailedPrecondition: {
		Code:        FailedPrecondition,
		MessageTpl:  "Failed precondition: {{reason}}",
		ConnectCode: connect.CodeFailedPrecondition,
		Retryable:   false,
	},
	Aborted: {
		Code:        Aborted,
		MessageTpl:  "Operation aborted: {{reason}}",
		ConnectCode: connect.CodeAborted,
		Retryable:   true,
	},
	Unimplemented: {
		Code:        Unimplemented,
		MessageTpl:  "Operation not implemented",
		ConnectCode: connect.CodeUnimplemented,
		Retryable:   false,
	},
	Canceled: {
		Code:        Canceled,
		MessageTpl:  "Operation canceled",
		ConnectCode: connect.CodeCanceled,
		Retryable:   false,
	},
	DataLoss: {
		Code:        DataLoss,
		MessageTpl:  "Unrecoverable data loss",
		ConnectCode: connect.CodeDataLoss,
		Retryable:   false,
	},
}

// Register adds or updates an error definition in the global Registry.
// It is safe for concurrent use. Uses copy-on-write for lock-free reads.
//
// Example:
//
//	connectgoerrors.Register(connectgoerrors.Error{
//	    Code:        "ERROR_CUSTOM",
//	    MessageTpl:  "Custom error: {{detail}}",
//	    ConnectCode: connect.CodeInternal,
//	    Retryable:   false,
//	})
func Register(err Error) {
	writeMu.Lock()
	defer writeMu.Unlock()
	current := loadRegistry()
	updated := make(map[string]Error, len(current)+1)
	for k, v := range current {
		updated[k] = v
	}
	updated[err.Code] = err
	registryVal.Store(updated)
}

// RegisterAll adds multiple error definitions to the global Registry.
// It is safe for concurrent use. Uses copy-on-write for lock-free reads.
func RegisterAll(errs []Error) {
	writeMu.Lock()
	defer writeMu.Unlock()
	current := loadRegistry()
	updated := make(map[string]Error, len(current)+len(errs))
	for k, v := range current {
		updated[k] = v
	}
	for _, err := range errs {
		updated[err.Code] = err
	}
	registryVal.Store(updated)
}

// Lookup retrieves an error definition from the Registry by its code.
// Lock-free: uses atomic load, no mutex overhead.
//
// Example:
//
//	e, ok := connectgoerrors.Lookup(connectgoerrors.NotFound)
func Lookup(code string) (Error, bool) {
	m := loadRegistry()
	e, ok := m[code]
	return e, ok
}

// MustLookup retrieves an error definition by code and panics if not found.
// Use this only during initialization or in tests.
func MustLookup(code string) Error {
	e, ok := Lookup(code)
	if !ok {
		panic(fmt.Sprintf("connectgoerrors: unknown error code %q", code))
	}
	return e
}

// Codes returns all registered error codes in sorted order.
// Useful for debugging, documentation, or building admin UIs.
func Codes() []string {
	m := loadRegistry()
	codes := make([]string, 0, len(m))
	for k := range m {
		codes = append(codes, k)
	}
	sort.Strings(codes)
	return codes
}

// loadRegistry returns the current immutable registry snapshot.
func loadRegistry() map[string]Error {
	v := registryVal.Load()
	if v == nil {
		return nil
	}
	return v.(map[string]Error)
}

func init() {
	registryVal.Store(defaultErrors)
}
