package connectgoerrors

import (
	"fmt"
	"sort"
	"sync"
	"sync/atomic"

	"connectrpc.com/connect"
)

// Error code constants for common RPC error scenarios.
// These are auto-generated by protoc-gen-connect-errors or defined manually.
const (
	// ErrNotFound indicates the requested resource was not found.
	ErrNotFound ErrorCode = "ERROR_NOT_FOUND"

	// ErrInvalidArgument indicates a client-supplied argument was invalid.
	ErrInvalidArgument ErrorCode = "ERROR_INVALID_ARGUMENT"

	// ErrAlreadyExists indicates an attempt to create a resource that already exists.
	ErrAlreadyExists ErrorCode = "ERROR_ALREADY_EXISTS"

	// ErrPermissionDenied indicates the caller lacks permission for the operation.
	ErrPermissionDenied ErrorCode = "ERROR_PERMISSION_DENIED"

	// ErrUnauthenticated indicates the request lacks valid authentication credentials.
	ErrUnauthenticated ErrorCode = "ERROR_UNAUTHENTICATED"

	// ErrInternal indicates an unexpected internal server error.
	ErrInternal ErrorCode = "ERROR_INTERNAL"

	// ErrUnavailable indicates the service is currently unavailable.
	ErrUnavailable ErrorCode = "ERROR_UNAVAILABLE"

	// ErrDeadlineExceeded indicates the operation timed out.
	ErrDeadlineExceeded ErrorCode = "ERROR_DEADLINE_EXCEEDED"

	// ErrResourceExhausted indicates some resource has been exhausted (e.g. rate limit).
	ErrResourceExhausted ErrorCode = "ERROR_RESOURCE_EXHAUSTED"

	// ErrFailedPrecondition indicates the operation was rejected because
	// the system is not in a state required for execution.
	ErrFailedPrecondition ErrorCode = "ERROR_FAILED_PRECONDITION"

	// ErrAborted indicates the operation was aborted (e.g. concurrency conflict).
	ErrAborted ErrorCode = "ERROR_ABORTED"

	// ErrOutOfRange indicates a value is out of the accepted range.
	ErrOutOfRange ErrorCode = "ERROR_OUT_OF_RANGE"

	// ErrUnimplemented indicates the operation is not implemented or supported.
	ErrUnimplemented ErrorCode = "ERROR_UNIMPLEMENTED"

	// ErrCanceled indicates the operation was canceled by the caller.
	ErrCanceled ErrorCode = "ERROR_CANCELED"

	// ErrDataLoss indicates unrecoverable data loss or corruption.
	ErrDataLoss ErrorCode = "ERROR_DATA_LOSS"
)

// Error represents a Connect RPC error definition with template support.
// It maps a semantic error code to a Connect status code and message template.
type Error struct {
	// Code is the unique error identifier (e.g. "ERROR_NOT_FOUND").
	Code string

	// MessageTpl is a message template with {{placeholder}} syntax.
	MessageTpl string

	// ConnectCode is the Connect RPC status code for this error.
	ConnectCode connect.Code

	// Retryable indicates whether the client should retry the request.
	Retryable bool
}

// writeMu protects Registry writes. Reads are lock-free via atomic.Value.
var writeMu sync.Mutex

// registryVal stores an immutable map[string]Error snapshot.
// Reads are lock-free (atomic load). Writes copy-on-write under writeMu.
var registryVal atomic.Value

// defaultErrors is the default error definitions. This is used to initialize registryVal.
// After init, use Lookup/Register/RegisterAll to interact with the registry.
var defaultErrors = map[string]Error{
	string(ErrNotFound): {
		Code:        string(ErrNotFound),
		MessageTpl:  "Resource '{{id}}' not found",
		ConnectCode: connect.CodeNotFound,
		Retryable:   false,
	},
	string(ErrInvalidArgument): {
		Code:        string(ErrInvalidArgument),
		MessageTpl:  "Invalid argument: {{reason}}",
		ConnectCode: connect.CodeInvalidArgument,
		Retryable:   false,
	},
	string(ErrAlreadyExists): {
		Code:        string(ErrAlreadyExists),
		MessageTpl:  "Resource '{{id}}' already exists",
		ConnectCode: connect.CodeAlreadyExists,
		Retryable:   false,
	},
	string(ErrPermissionDenied): {
		Code:        string(ErrPermissionDenied),
		MessageTpl:  "Permission denied: {{reason}}",
		ConnectCode: connect.CodePermissionDenied,
		Retryable:   false,
	},
	string(ErrUnauthenticated): {
		Code:        string(ErrUnauthenticated),
		MessageTpl:  "Authentication required",
		ConnectCode: connect.CodeUnauthenticated,
		Retryable:   false,
	},
	string(ErrInternal): {
		Code:        string(ErrInternal),
		MessageTpl:  "Internal server error",
		ConnectCode: connect.CodeInternal,
		Retryable:   false,
	},
	string(ErrUnavailable): {
		Code:        string(ErrUnavailable),
		MessageTpl:  "Service temporarily unavailable",
		ConnectCode: connect.CodeUnavailable,
		Retryable:   true,
	},
	string(ErrDeadlineExceeded): {
		Code:        string(ErrDeadlineExceeded),
		MessageTpl:  "Request timed out",
		ConnectCode: connect.CodeDeadlineExceeded,
		Retryable:   true,
	},
	string(ErrResourceExhausted): {
		Code:        string(ErrResourceExhausted),
		MessageTpl:  "Resource exhausted: {{reason}}",
		ConnectCode: connect.CodeResourceExhausted,
		Retryable:   true,
	},
	string(ErrFailedPrecondition): {
		Code:        string(ErrFailedPrecondition),
		MessageTpl:  "Failed precondition: {{reason}}",
		ConnectCode: connect.CodeFailedPrecondition,
		Retryable:   false,
	},
	string(ErrAborted): {
		Code:        string(ErrAborted),
		MessageTpl:  "Operation aborted: {{reason}}",
		ConnectCode: connect.CodeAborted,
		Retryable:   true,
	},
	string(ErrOutOfRange): {
		Code:        string(ErrOutOfRange),
		MessageTpl:  "Value out of range: {{reason}}",
		ConnectCode: connect.CodeOutOfRange,
		Retryable:   false,
	},
	string(ErrUnimplemented): {
		Code:        string(ErrUnimplemented),
		MessageTpl:  "Operation not implemented",
		ConnectCode: connect.CodeUnimplemented,
		Retryable:   false,
	},
	string(ErrCanceled): {
		Code:        string(ErrCanceled),
		MessageTpl:  "Operation canceled",
		ConnectCode: connect.CodeCanceled,
		Retryable:   false,
	},
	string(ErrDataLoss): {
		Code:        string(ErrDataLoss),
		MessageTpl:  "Unrecoverable data loss",
		ConnectCode: connect.CodeDataLoss,
		Retryable:   false,
	},
}

// Register adds or updates an error definition in the global Registry.
// It is safe for concurrent use. Uses copy-on-write for lock-free reads.
//
// Example:
//
//	connectgoerrors.Register(connectgoerrors.Error{
//	    Code:        "ERROR_CUSTOM",
//	    MessageTpl:  "Custom error: {{detail}}",
//	    ConnectCode: connect.CodeInternal,
//	    Retryable:   false,
//	})
func Register(err Error) {
	writeMu.Lock()
	defer writeMu.Unlock()
	current := loadRegistry()
	updated := make(map[string]Error, len(current)+1)
	for k, v := range current {
		updated[k] = v
	}
	updated[err.Code] = err
	registryVal.Store(updated)
}

// RegisterAll adds multiple error definitions to the global Registry.
// It is safe for concurrent use. Uses copy-on-write for lock-free reads.
func RegisterAll(errs []Error) {
	writeMu.Lock()
	defer writeMu.Unlock()
	current := loadRegistry()
	updated := make(map[string]Error, len(current)+len(errs))
	for k, v := range current {
		updated[k] = v
	}
	for _, err := range errs {
		updated[err.Code] = err
	}
	registryVal.Store(updated)
}

// Lookup retrieves an error definition from the Registry by its code.
// Lock-free: uses atomic load, no mutex overhead.
//
// Example:
//
//	e, ok := connectgoerrors.Lookup(connectgoerrors.ErrNotFound)
func Lookup(code ErrorCode) (Error, bool) {
	m := loadRegistry()
	e, ok := m[string(code)]
	return e, ok
}

// MustLookup retrieves an error definition by code and panics if not found.
// Use this only during initialization or in tests.
func MustLookup(code ErrorCode) Error {
	e, ok := Lookup(code)
	if !ok {
		panic(fmt.Sprintf("connectgoerrors: unknown error code %q", code))
	}
	return e
}

// Codes returns all registered error codes in sorted order.
// Useful for debugging, documentation, or building admin UIs.
func Codes() []string {
	m := loadRegistry()
	codes := make([]string, 0, len(m))
	for k := range m {
		codes = append(codes, k)
	}
	sort.Strings(codes)
	return codes
}

// loadRegistry returns the current immutable registry snapshot.
func loadRegistry() map[string]Error {
	v := registryVal.Load()
	if v == nil {
		return nil
	}
	return v.(map[string]Error)
}

func init() {
	registryVal.Store(defaultErrors)
}
